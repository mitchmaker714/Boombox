{
  "name": "Boombox Kaleidoscope",
  "id": "QibeaQvfEnCr8ZEc4",
  "sources": {
    "main": "export var WIDTH              = 32;\nexport var HEIGHT             = pixelCount / WIDTH;\nexport var light              = -1;\nexport var frequencyData      = array(32);\nexport var pic                = makePIController(10, 0.15, 200, 0, 1600);\nexport var sensitivity        = 0;\nexport var brightnessFeedback = 0;\nexport var averages           = array(32);\n\n// ── NEW: scale/threshold for raw FFT data ───────────────\nexport var dataScale          = 0.8;    // multiply raw FFT by this (<1 to shrink)\nexport var dataThreshold      = 0.02;   // floor: ignore anything below this\n\nvar averageWindowMs = 1500;\nvar fade            = 0.7;\nvar attack          = 0.7;\nvar speed           = 10;\nvar targetFill      = 0.3;\n\nvar pixels          = array(pixelCount);\nvar s, dw, t1, frameFade, frameFadeM, accumDelta = 0;\nvar BPM             = 120;\nvar measurePeriod   = 4 * 60 / BPM / 65.536;\n\nfunction makePIController(kp, ki, start, min, max) {\n  var p = array(5);\n  p[0] = kp; p[1] = ki; p[2] = start; p[3] = min; p[4] = max;\n  return p;\n}\n\nfunction calcPIController(pic, err) {\n  pic[2] = clamp(pic[2] + err, pic[3], pic[4]);\n  return max(pic[0] * err + pic[1] * pic[2], 0.3);\n}\n\nexport function beforeRender(delta) {\n  sensitivity        = calcPIController(pic, targetFill - brightnessFeedback / pixelCount);\n  brightnessFeedback = 0;\n  t1                 = time(speed / 65.536);\n  if (light === -1) doAt(40, delta, simulateSound);\n  dw = delta / averageWindowMs;\n  for (var i = 0; i < 32; i++) {\n    averages[i] = max(0.0001,\n      averages[i] * (1 - dw) +\n      frequencyData[i] * dw * sensitivity\n    );\n  }\n  resetTransform();\n  translate3D(-0.5, -0.5, -0.5);\n  s = 0.5 + 3 * wave(time(1));\n  scale3D(s, s, s);\n}\n\nfunction arrayLerp(arr, i) {\n  var ifloor = floor(i), iceil = ceil(i), ratio = i - ifloor;\n  return arr[ifloor] * (1 - ratio) + arr[iceil] * ratio;\n}\n\nexport function render2D(index, x, y) {\n  // which “bin” we sample along the swirling line\n  var i = 31 * triangle(triangle(hypot(x, y)) - t1);\n\n  // ── 1) pull in the FFT, scale it down, apply a little floor\n  var rawFreq = arrayLerp(frequencyData, i) * dataScale;\n  rawFreq     = rawFreq > dataThreshold ? rawFreq - dataThreshold : 0;\n\n  // ── 2) compute raw brightness using your original formula\n  var rawV = (rawFreq * sensitivity -\n              arrayLerp(averages, i))\n             * (arrayLerp(averages, i) * 10 + 10);\n  var v    = rawV > 0 ? rawV * rawV : 0;\n\n  // hue swept by position + swirl angle\n  var h    = (i / 31 + triangle(atan2(y, x) / PI * 2) * 0.5) % 1;\n\n  // smooth & feedback\n  pixels[index] = pixels[index] * fade + v * attack;\n  v             = pixels[index];\n\n  // full-saturation rainbow\n  var sat = v > 0 ? 1 : 0;\n\n  brightnessFeedback += clamp(v, 0, 1);\n  return hsv(h, sat, v);\n}\n\nfunction doAt(hz, delta, fn) {\n  accumDelta += delta;\n  if (accumDelta > 1000 / hz) {\n    accumDelta -= 1000 / hz;\n    fn();\n  }\n}\n\nfunction simulateSound() {\n  var tM = time(measurePeriod), tP = time(8 * measurePeriod);\n  for (var j = 0; j < 32; j++) frequencyData[j] = 0;\n  var beat = (-4 * tM + 5) % 1; beat *= 0.02 * pow(beat, 4);\n  for (var k = 0; k < 10; k++)\n    frequencyData[k] += beat * (10 - k) / 10;\n  var claps = 0.006 * square(2 * tM - 0.5, 0.10);\n  for (var m = 9; m < 14 + random(5); m++)\n    frequencyData[m] += claps * (0.7 + 0.6 * random(m % 2));\n  var highHat = 0.01 * square(4 * tM - 0.5, 0.05);\n  for (var n = 18; n < 20; n++)\n    frequencyData[n] += highHat * (0.8 + random(0.4));\n  var lead = 4 + floor(16 * wander(tP));\n  for (var o = 4; o < 20; o++)\n    if (lead === o || lead === (o - 4) * r(0.4))\n      frequencyData[o] += 0.005;\n}\n\nfunction wander(t) {\n  t *= 49.261;\n  return (wave(t / 2) * wave(t / 3) * wave(t / 5) + wave(t / 7)) / 2;\n}\n\nfunction r(p) {\n  return random(1) < p;\n}"
  },
  "preview": "/9j/4AAQSkZJRgABAQAAAQABAAD/4gHYSUNDX1BST0ZJTEUAAQEAAAHIAAAAAAQwAABtbnRyUkdCIFhZWiAH4AABAAEAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAACRyWFlaAAABFAAAABRnWFlaAAABKAAAABRiWFlaAAABPAAAABR3dHB0AAABUAAAABRyVFJDAAABZAAAAChnVFJDAAABZAAAAChiVFJDAAABZAAAAChjcHJ0AAABjAAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAAgAAAAcAHMAUgBHAEJYWVogAAAAAAAAb6IAADj1AAADkFhZWiAAAAAAAABimQAAt4UAABjaWFlaIAAAAAAAACSgAAAPhAAAts9YWVogAAAAAAAA9tYAAQAAAADTLXBhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABtbHVjAAAAAAAAAAEAAAAMZW5VUwAAACAAAAAcAEcAbwBvAGcAbABlACAASQBuAGMALgAgADIAMAAxADb/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCACWAGQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAn/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//9k="
}